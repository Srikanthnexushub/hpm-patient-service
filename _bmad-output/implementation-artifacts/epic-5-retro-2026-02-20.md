# Epic 5 Retrospective — Quality, Security & Hardening
**Date:** 2026-02-20
**Epic:** Epic 5 — Quality, Security & Hardening
**Facilitator:** Bob (Scrum Master)
**Project Lead:** Srikanth
**Team:** Bob (SM), John (PM), Amelia (Developer), Quinn (QA Engineer)

---

## Epic Summary

| Metric | Value |
|---|---|
| Stories completed | 3 / 3 (100%) |
| Stories | 5-1 Remove PHI from Logs, 5-2 Test Suite, 5-3 Fix Race Condition |
| Bonus fix (live testing) | `bloodGroup` null constraint — discovered during Docker verification |
| Test count delta | 42 → 55 tests (+13) |
| Issues caught by code review | 12 HIGH/MEDIUM before production |
| Issues caught only by live testing | 1 (bloodGroup null on update) |
| Previous retrospective | None (first retrospective) |
| Next epic | None (full roadmap delivered) |

---

## What Went Well

### 1. Adversarial Code Review as Epic Generator
The code review was not originally in scope — it was added as a BMAD workflow step. It returned 12 HIGH and MEDIUM findings that became the entire content of Epic 5: PHI log exposure (5-1), test suite gaps (5-2), and the patient ID race condition (5-3).

**Key insight from Srikanth:** *"The code review helped catch critical issues before production."*

Without the review, the service would have shipped with:
- A broken `@Transactional(SERIALIZABLE)` that was a complete no-op (AOP proxy bypass)
- `PatientStatus.ALL` as a JPA entity enum value — would cause a DB check constraint violation on any INSERT
- PHI (names, phones, emails) leaking into logs via `toString()`
- Generic 500 handler echoing `ex.getMessage()` — Hibernate exceptions contain SQL fragments and field values

### 2. Single Fix, Two Problems Solved
Extracting `PatientIdGeneratorService` as a separate Spring bean with the `PatientIdGenerator` interface fixed:
- The AOP proxy bypass (self-call `this.method()` bypasses the Spring proxy)
- The Java 25 / Mockito limitation (byte-buddy cannot mock concrete classes — the interface solved it)

One architectural move, two unrelated problems resolved.

### 3. project-context.md Pays Off Immediately
The `project-context.md` artifact (42 rules, 10 sections) was generated at the end of the sprint. Within the same session, three parallel AI agents used it to build a complete React frontend — correct API contract, correct enum values, correct response envelope handling — on the first attempt. Zero API contract errors.

### 4. Comprehensive PHI Safety
`@ToString(exclude)` applied to: `Patient` entity, `PatientRegistrationRequest`, `PatientUpdateRequest`, `PatientResponse`, `PatientSummaryResponse`. Generic 500 handler returns a fixed safe string. No PHI reachable via logs, exception messages, or toString output.

---

## Challenges

### 1. Integration Test Gap — DB Constraints Never Exercised
**The bloodGroup null bug:** `PatientMapper.updateEntity()` unconditionally called `patient.setBloodGroup(request.getBloodGroup())`, setting null when the field was omitted from the request body. `bloodGroup` is NOT NULL in the DB.

- 55 unit tests passed ✅
- Adversarial code review passed ✅
- Bug surfaced on first live PUT request in Docker ❌

**Root cause:** Unit tests mock `PatientRepository` — the real PostgreSQL DB constraint is never reached. The test pyramid had no layer that exercised DB-enforced constraints.

**Decision (Srikanth):** Add Testcontainers integration tests for the DB layer.

### 2. Java 25 / Mockito Incompatibility Discovered Mid-Sprint
Mockito's inline byte-buddy mock-maker cannot mock or spy concrete classes on Java 25 (Homebrew JDK). Tests failed with NPE during teardown. Discovered mid-Story 5-2, not at project setup.

**Impact:** Required mid-sprint interface extraction (`PatientIdGenerator`). The pattern turned out to be correct architecture, but the discovery timing wasted effort.

**Fix:** Runtime/toolchain compatibility check at project setup, before sprint kickoff.

---

## Action Items

### Technical

| # | Action | Owner | Success Criteria |
|---|---|---|---|
| T1 | Add Testcontainers + `@DataJpaTest` integration tests for `PatientRepository` | Amelia | Covers: NOT NULL constraints, unique constraints, `findMaxCounterForYear()`, Specification filters (status/gender/bloodGroup/search), optimistic locking round-trip. The bloodGroup null scenario fails before fix, passes after. |

**Scope for T1:**
- `save()` with missing NOT NULL fields → expect constraint violation
- `save()` with duplicate `patientId` → expect unique constraint violation
- `existsByPhoneNumber()` and `existsByPhoneNumberAndPatientIdNot()`
- `findMaxCounterForYear()` — the patient ID generation counter query
- Specification-based search: status filter, gender filter, bloodGroup filter, text search, combined filters
- Optimistic locking: concurrent update → expect `OptimisticLockingFailureException`

### Process

| # | Action | Owner | Success Criteria |
|---|---|---|---|
| P1 | Add runtime/toolchain compatibility check to project setup | Bob | JDK version vs. Mockito/byte-buddy compatibility verified on day 0; documented in `project-context.md` |

---

## Team Agreements

1. **Code review is mandatory before any story is marked done** — adversarial framing ("find everything wrong"), not a courtesy check
2. **Testcontainers is the correct tool for DB constraint scenarios** — unit tests alone are insufficient for persistence logic involving NOT NULL, unique, or check constraints
3. **Partial update fields that are NOT NULL in DB must have null-guard in mapper** — pattern: `if (request.getField() != null) { entity.setField(...); }`

---

## Readiness Assessment

| Dimension | Status | Notes |
|---|---|---|
| Testing & Quality | ⚠️ Partial | 55 unit tests passing; DB integration tests pending (T1) |
| Deployment | ✅ Done | Docker compose healthy; frontend running on port 3000 |
| Technical Health | ✅ Solid | Race condition fixed, PHI safe, audit trail complete, bloodGroup guard added |
| Unresolved Blockers | ✅ None | — |
| Frontend | ✅ Shipped | React UI connected to live API, committed and pushed |

---

## Key Lessons

1. **The test suite validates business logic, not persistence contracts.** Unit tests mock the DB away — fast but blind to schema enforcement. DB-layer constraints require a real DB to exercise.

2. **Adversarial code review finds what development misses.** 12 issues in 30 minutes. The framing matters: "find everything wrong" yields different results than "check this looks okay."

3. **Institutional knowledge as artifact.** `project-context.md` enabled correct autonomous implementation on first attempt. Document the unobvious rules, not the obvious ones.

4. **Runtime compatibility is a day-0 concern.** JDK version vs. test toolchain compatibility should be verified before the first story, not discovered mid-sprint.

---

## Next Steps

1. Implement Testcontainers integration test suite (action item T1)
2. Add toolchain compatibility check to project setup process (action item P1)
3. Update `project-context.md` with Testcontainers pattern once implemented

---

_Retrospective facilitated by BMAD Sprint workflow. Generated 2026-02-20._
