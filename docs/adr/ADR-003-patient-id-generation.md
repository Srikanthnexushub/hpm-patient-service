# ADR-003: Sequential Year-Based Patient ID Generation (P{year}{counter})

| Field | Value |
|---|---|
| **Status** | Accepted (Under Review for multi-instance deployments) |
| **Date** | 2026-02-20 |
| **Authors** | Ai Nexus Engineering Team |
| **Deciders** | Engineering Lead, Architect |
| **Ticket** | HPM-003 |

---

## Context

Every patient registered in the HPM system requires a unique, stable, permanent identifier assigned at registration time. This identifier is used by hospital staff for:

- Patient look-up at reception
- Printed wristbands and ID cards
- Cross-referencing with other modules (appointments, billing, pharmacy)
- Audit trail references

The identifier must satisfy the following requirements:

| Requirement | Rationale |
|---|---|
| Human-readable and speakable | Staff must be able to read the ID verbally over phone to confirm patient identity |
| Year-scoped | Allows staff to quickly know which year a patient was registered; useful for record grouping and archival |
| Sequential within a year | Natural ordering gives front desk staff an intuitive sense of patient volume |
| Unique across all records | Primary key constraint; no collisions permitted |
| Compact | Short enough to fit on printed labels and wristbands |

Options evaluated:

1. **UUID v4** — randomly generated universally unique identifier
2. **PostgreSQL SERIAL / BIGSERIAL** — database-managed auto-increment integer
3. **Custom P{YEAR}{COUNTER} format** — application-managed sequential counter scoped by year
4. **Redis atomic counter** — distributed counter using `INCR` command
5. **Snowflake ID** — Twitter-style timestamp-based distributed ID

---

## Decision

Use a **custom sequential year-based format**:

```
P + {4-digit-year} + {3-digit-zero-padded-counter}
```

**Examples:**
- `P2026001` — first patient of 2026
- `P2026042` — 42nd patient of 2026
- `P2027001` — first patient of 2027 (counter resets)

**Implementation:**
The next ID is generated by executing a `MAX(patient_id)` query filtered to the current year prefix, extracting the counter, incrementing by 1, and formatting the new ID. The method is declared `synchronized` to prevent concurrent ID generation within a single JVM instance.

---

## Rationale

### Why This Format

**Human Readability**: `P2026001` is phonetically clear — "P twenty-twenty-six zero zero one." Staff can communicate it unambiguously. A UUID like `a3f7c2d1-8b4e-4f9c-b2a1-7d3e5f8c9b0a` is not communicable verbally.

**Year Scoping**: The year prefix allows immediate date context. A billing clerk seeing `P2024031` knows immediately this is a 2024 patient without querying the database. The counter resets annually, mirroring how hospitals group patient volumes per calendar year.

**Compact Format**: 8 characters (`P` + 4-digit year + 3-digit counter) fits comfortably on labels, wristbands, and printed forms.

**Counter Width**: 3-digit counter supports up to 999 patients per year. For hospitals expecting higher volume, this should be extended to 4 or 5 digits (see Consequences).

### Why Synchronized Generation is Acceptable (for Now)

In a single-instance deployment (the current architecture), `synchronized` guarantees mutual exclusion at no meaningful performance cost — patient registration is not a high-throughput operation. The overhead of the MAX query plus synchronized block is negligible compared to the full registration transaction.

---

## Consequences

### Positive

- IDs are immediately interpretable by hospital staff without a database lookup.
- Year-scoped counter simplifies annual patient volume reporting.
- No external dependency required (no Redis, no dedicated sequence service).
- Simple to implement: one synchronized method, one MAX query.
- Counter resets each year, keeping IDs short and year-cohesive.

### Negative

**Single-instance limitation**: The `synchronized` keyword only provides mutual exclusion within a single JVM. In a horizontally scaled deployment (multiple pods/containers), two instances could generate the same ID if both execute the MAX query concurrently before either commits. This is a known limitation.

**Mitigation for multi-instance**: For horizontal scaling, replace the MAX-based generation with one of:
1. **PostgreSQL sequence per year**: `CREATE SEQUENCE patient_seq_2026 START 1;` — atomic, database-guaranteed uniqueness.
2. **Redis `INCR` counter**: `INCR patient:2026:counter` — atomic, sub-millisecond, distributed-safe.
3. **Database unique constraint as safety net**: Even with the current implementation, the `patient_id` column has a PRIMARY KEY constraint, so a duplicate will cause a constraint violation that the application can catch and retry.

**Counter overflow at 999**: The 3-digit counter supports 999 patients per year. If patient volume exceeds this, IDs like `P20261000` (4-digit counter) will be generated — the format degrades gracefully but loses visual consistency. **Recommendation**: Expand to 4-digit counter (`P20260001`) proactively if annual patient volume is expected to exceed 500.

**No randomness**: Sequential IDs are enumerable — an adversary who knows one patient ID can guess adjacent IDs. For this reason, patient ID alone must never be treated as an access control mechanism. Authentication and authorization must be enforced independently.

---

## Alternatives Considered

| Option | Pros | Cons | Reason Not Selected |
|---|---|---|---|
| **UUID v4** | Globally unique, safe for distributed generation, no coordination needed | Not human-readable; 36 characters; not year-scoped; staff cannot communicate verbally | Fails the human-readability requirement |
| **PostgreSQL SERIAL / BIGSERIAL** | Database-guaranteed uniqueness; simple | Produces raw integers (`1`, `2`, `42`); no year prefix; not interpretable without context | Fails year-scoping and human-readability requirements |
| **Redis INCR counter** | Atomic, distributed-safe, no DB overhead | Adds Redis as a required infrastructure dependency; introduces operational complexity and a failure mode | Dependency cost not justified for single-instance deployment; deferred to future scaling phase |
| **Snowflake ID** | Distributed-safe, timestamp-embedded, compact integer | Complex to implement; not human-readable; overkill for patient ID use case | Over-engineering for current requirements |
| **Database sequence per year** | Atomic, distributed-safe, no application synchronization | Requires DDL changes each year; needs annual automation (`CREATE SEQUENCE patient_seq_{YEAR}`) | Operationally cumbersome; preferred as a migration path when multi-instance scaling is adopted |

---

## Future Migration Path

When the service is scaled to multiple instances:

```sql
-- Create year-scoped sequence (run once per year, automated via migration)
CREATE SEQUENCE IF NOT EXISTS patient_id_seq_2027 START 1 INCREMENT 1 NO CYCLE;

-- Application generates ID as:
-- 'P' || to_char(CURRENT_DATE, 'YYYY') || lpad(nextval('patient_id_seq_' || to_char(CURRENT_DATE, 'YYYY'))::text, 3, '0')
```

This approach retains the `P{YEAR}{COUNTER}` format while eliminating the single-JVM synchronization constraint.

---

## Review

This decision will be revisited when:
- The service is deployed with more than one running instance (horizontal scaling).
- Annual patient registration volume approaches 800+ records (counter overflow risk).
